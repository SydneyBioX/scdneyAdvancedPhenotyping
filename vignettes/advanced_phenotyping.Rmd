---
title: "Advanced Phenotyping in Single Cell Data Analysis"
author: Yingxin Lin^[yinxin.lin@sydney.edu.au]
        Hani Jieun Kim^[hani.kim@sydney.edu.au]
        Carissa Chen^[cchen@uni.sydney.edu.au]
output: 
  rmarkdown::html_vignette:
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteIndexEntry{Advanced Phenotyping in Single Cell Data Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
set.seed(2021)
```

## Overview

### Description

This workshop on the "Advanced Phenotyping in Single Cell Data Analysis" teaches workflows for the phenotyping of single cells. Phenotyping broadly refers to all procedures that attempts to characterize the identity and/or state of cells and the relationship between cells and generally is preceded by pre-processing, normalisation and clustering of single cell data. 

### Pre-requisites

The workshop requires basic knowledge of the following topics:

* Knowledge of R syntax
* Basic knowledge in [single cell data analysis](https://bioconductor.org/books/release/OSCA/index.html)
* Familiarity with the [SingleCellExperiment class](https://www.bioconductor.org/packages/release/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html)
* Familiarity with our previous workshop vignette on [Introduction to Single Cell RNA-seq Analysis](https://sydneybiox.github.io/BIS2019_SC/)

Relevant background reading for the workshop can be found in the links above.

### Time outline

Structure of the 2-hour workshop:

| Activity                     | Time |
|------------------------------|------|
| Accessing the cloud          | 5m   |
| Introduction                 | 10m  |
| Building a trajectory        | 30m  |
| Characterizing the trajectory| 40m  |
| Cell-cell communication      | 30m  |
| Concluding remarks           | 5m   |

### Workshop goals and objectives

The overall *learning goals* of the workshop is to understand the basic workflows of two common approaches to phenotype the cell: trajectory analysis and cell-cell interaction. We will also discuss the general challenges associated with phenotyping single cells and future perspectives.

### Learning goals

* describe various ways to phenotype single cells 
* identify different workflows to build and characterize a trajectory
* understand how cell-cell communication can be used to distinguish cell types

### Learning objectives

* analyze a single cell RNA-seq data to build a trajectory, calculate pseudo-times, find differentially expressed genes across trajectories, and identify cell-cell interactions
* create plots to visualise the trajectories and expression of genes
* evaluate the single cell data to identify genes that distinguish trajectories and ligand-receptor interactions that distinguish cell types

## 1. Introduction

Many biological processes manifest as a continuum of dynamic changes and diverse cellular states. One of the major goals of single cell data analysis is to identify and characterize these cell types and states that are induced from external stimulation (such as environmental insults or perturbations), the spatial context, the point along the differentiation system in which a cell lies and more. Collectively, these biological, genetic and environmental factors contribute towards the diversity of the phenotypes we see among cells. 

We define the process of phenotyping as any procedure that attempts to further characterize the identity and/or state of cells and the relationship between cells and is distinct from procedures relating to the pre-processing or clustering of the data. One of the most common and basic phenotyping procedure is cell type identification, which is a highly researched topic in single cell data analysis. We can further explore various characteristics of the cells by 1) investigating where a cell lies along a trajectory, if the data demonstrates a pseudo-temporally ordered state; 2) determining if there are multiple branches in the trajectory (which may associate with different cell type lineages); 3) if the previous is true, distinguishing if certain gene expression programs are associated with a certain trajectory through differential expression analysis or gene set enrichment studies; and lastly 4) investigating if a certain signalling patterns can be observe between cell types. Collectively, these efforts contribute towards phenotyping the data and obtaining a more descriptive characterization of the data at hand.

Thus, the question becomes how do we identify the diverse phenotypes? Whilst single cell data enables us to interrogate the heterogeneity among the phenotypes and tease out different and distinct states, a cell's phenotype is the manifestation of a collective and integrated output of a set of molecules or networks that span across multiple modalities (transcriptome, genome, epigenome, and proteome etc). In this workshop, we begin to investigate this using single-cell transcriptomes, acknowledging at the same time that a single modality alone may not be sufficient to accurately pinpoint all the phenotypes present in the data. 

In this workshop, we will demonstrate two different approaches to phenotyping, trajectory analysis and cell-cell communication, using a mouse scRNA-seq data profiling the hippocampus dataset from [La Manno et al. (2018)](https://www.nature.com/articles/s41586-018-0414-6#additional-information).

## 2. Loading libraries and the data

### 2.1 Load libraries

First, let us load some of the libraries we will be using in this workshop. 
```{r message = FALSE}
library(SingleCellExperiment)
library(scater)
library(Cepo)
library(slingshot)
library(ggthemes)
library(ggridges)
library(reshape2)
library(scran)
library(ggpubr)
library(DT)
library(UpSetR)
theme_set(theme_bw())
```

### 2.2 Loading the preprocessed data

We will use the mouse hippocampus scRNA-seq dataset from [La Manno et al. (2018)](https://www.nature.com/articles/s41586-018-0414-6#additional-information). We provide the processed version in this workshop, which is subsampled (12,935 cells) from the original data (18,213 cells). The sampled data contains cells from two post-natal time points (P0 and P5) and a total of 8 cell types. The original data can be access from GEO with the accession number GSE104323.

```{r}
# code to load data 
sce <- readRDS("data/sce_DentateGyrus_hippocampus.rds")
sce <- scater::logNormCounts(sce)
```

### 2.3 Visualising the data

We will visualise the data using four different dimensionality reduction approaches and color the individual data points (denoting single cells) by their cell type labels. Without much knowledge of the biological system, can you guess whether the data contains discrete or continuous cell types just by evaluating these plots?

```{r fig.height=6}
sce <- scater::runPCA(sce, scale = TRUE)
sce <- scater::runUMAP(sce, dimred = "PCA")
sce <- scater::runTSNE(sce, dimred = "PCA")
sce <- scater::runDiffusionMap(sce, dimred = "PCA")


p1 <- plotPCA(sce, colour_by = "ClusterName") + ggtitle("PCA") 
p2 <- plotUMAP(sce, colour_by = "ClusterName") + ggtitle("UMAP")
p3 <- plotTSNE(sce, colour_by = "ClusterName") + ggtitle("TSNE")
p4 <- plotDiffusionMap(sce, colour_by = "ClusterName") + ggtitle("Diffusion Map")


ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2, common.legend = TRUE)
```

## 3. Trajectory inference: How can I infer the trajectory for my data?

The visualisations in *Step 2.3* suggests the presence of a clear trajectory. Starting from the progenitor cells (neuroblasts; Nbl1 and Nbl2), there is bifurcation of the trajectory into the two major lineages: the dentate gyrus granule neurons ("granule") and pyramidal neurons ("CA"). The subsequent steps illustrates an example workflow to infer the trajectory that represents this branching structure in the data. 

### 3.1 Perform feature selection using Cepo

One of the first steps of trajectory analysis is to perform feature selection. Given the high dimensional nature of high throughput single cell data, oftentimes it is advantageous to select for genes that provide biologically relevant information and remove those that add noise to the data. There are many ways to perform feature selection in single cell data, reviewed [here](add_link). In this workshop, we demonstrate feature selection using [differential stability](https://www.biorxiv.org/content/10.1101/2021.01.10.426138v1) from [Cepo](https://github.com/PYangLab/Cepo) to choose the top 100 cell identity genes for each cell type. 

```{r fig.height=6}
cepo = Cepo::Cepo(logcounts(sce), sce$ClusterName, exprsPct = 0.05)
cepoGenes = unique(unlist(Cepo::topGenes(cepo, n = 100)))

sce = scater::runPCA(sce, scale = TRUE, subset_row = cepoGenes)
sce = scater::runUMAP(sce, dimred = "PCA")
sce = scater::runTSNE(sce, dimred = "PCA")
sce = scater::runDiffusionMap(sce, dimred = "PCA")

p1 = plotPCA(sce, colour_by = "ClusterName") + ggtitle("643 Cepo genes") 
p2 = plotUMAP(sce, colour_by = "ClusterName") + ggtitle("643 Cepo genes")
p3 = plotTSNE(sce, colour_by = "ClusterName") + ggtitle("643 Cepo genes")
p4 = plotDiffusionMap(sce, colour_by = "ClusterName") + ggtitle("643 Cepo genes")

ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2, common.legend = TRUE)
```

Running the dimensionality reduction with the data subsetted for the differentially stable genes reveals (using a quick visual interpretation) a trajectory in the PCA space that is more consistent with those observed in UMAP, TSNE, and DM. 

### 3.2 Construct a trajectory using `slingshot` on UMAP reduced dimension space.

After dimensionality reduction, the next step in building the trajectory is to infer and construct the trajectory. Development of trajectory inference methods is actively evolving, and the effectiveness of current trajectory inference tools for transcriptomics data has been extensively reviewed in [this benchmarking paper](https://www.nature.com/articles/s41587-019-0071-9). We will run *slingshot* as an example in this workshop, for which more details of the implementation can be found [here](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-018-4772-0).

The basic input of slingshot is the expression matrix (as an SCE object), cell type labels, and the coordinates for the reduced dimensions. Slingshot implements a two-stage procedure whereby in the first step it infers the global lineage structure using the multi-spanning tree (MST) and then infers the pseudo-time for cells along each lineage by fitting simultaneous "principal curves" across multiple lineages. When known, we can also assign the starting node/cell type (i.e., "Nbl1").
```{r}
slingshot_umap <- slingshot(sce, 
                            clusterLabels = sce$ClusterName,
                            reducedDim = 'UMAP',
                            start.clus = "Nbl1")
```

Let us visualise the slingshot results using the base R plot approach.
```{r}
rd <- reducedDim(slingshot_umap, "UMAP")
plotcol <- tableau_color_pal("Classic 10")(10)[as.factor(slingshot_umap$ClusterName)]

# set the aspect ratio for base R plot as 1
par(pty = "s") 
plot(rd, col = plotcol, 
     pch = 16, asp = 1, xlab = "UMAP1", ylab = "UMAP2")
lines(SlingshotDataSet(slingshot_umap), lwd=2, col='black')
```

We can visualise the same results using `ggplot2`. Note that as expected we can see a total of three lineages that has been identified by slingshot, and the first bifurcation occurs at the junction of `Nbl1` and `Nbl2` and a second bifurcation at `CA` to give three terminal cell types, `CA1-Sub`, `CA2-3-4`, and `Granule`.
```{r}
df_toPlot <- data.frame(UMAP1 = rd[, 1],
                        UMAP2 = rd[, 2],
                        ClusterName = slingshot_umap$ClusterName)
pseudotime_umap <- slingshot::slingPseudotime(slingshot_umap)
df_toPlot <- cbind(df_toPlot, pseudotime_umap)

curves <- slingCurves(slingshot_umap, as.df = TRUE)
ggplot() +
  geom_point(data = df_toPlot, aes(x = UMAP1, y = UMAP2, color = ClusterName)) +
  geom_path(data = curves,
            aes(x = Dim.1, y = Dim.2, group = Lineage)) +
  scale_color_tableau(palette = "Classic 10") +
  theme(aspect.ratio = 1)
```

A more interesting visualisation would be to see how the pseudotimes have been inferred for the individual branches. By using the `slingshot::slingPseudotime` function, we can access the inferred pseudotimes for the individual cells for each of the lineages identified. 
```{r}
## visualising the psuedotime
df_toPlot2 <- reshape2::melt(df_toPlot, id = c("UMAP1", "UMAP2", "ClusterName"))
colnames(df_toPlot2) <- c("UMAP1", "UMAP2", "ClusterName", "Lineages", "Pseudotime")
ggplot() +
  geom_point(data = df_toPlot2, aes(x = UMAP1, y = UMAP2, color = Pseudotime)) +
  geom_path(data = curves,
            aes(x = Dim.1, y = Dim.2, group = Lineage)) +
  scale_color_viridis_c() +
  theme(aspect.ratio = 1) +
  facet_wrap(~Lineages)
```

Using the frequency of cells identified along the above pseudotime, we can also visualise the density of cells for each cell type along the three lineages using the `geom_density_ridges2` function. 
```{r}
ggplot() +
  geom_density_ridges2(data = df_toPlot2, 
                       aes(x = Pseudotime, y = ClusterName, fill = ClusterName), 
                       alpha = 0.5) +
  scale_fill_tableau(palette = "Classic 10") +
  theme(aspect.ratio = 1, legend.position = "bottom") +
  facet_wrap(~Lineages) 
```

**Discussion:** 

+ Do these orderings make sense given the cluster labels? Why?
+ Would specifying starting cluster (`start.clus`) or not impact our trajectory results?

Lastly, for users wanting to explore alternative methods to build the trajectory, please refer to the [dynverse framework](https://dynverse.org/), which provides a uniform interface to run more than 50 trajectory inference methods.

### 3.3 How does the choice of dimensionality reduction affect the trajectory inference?

Note that there are several parameters that may affect the final inferred pseudotime, such as the selection of features, the choice of dimensionality reduction technique, the method of lineage inference etc. Whilst it is beyond the scope of this workshop, finding the most optimal parameters may be data specific and requires close inspection of the final pseudotime against expected and known biological knowledge.

In this workshop, we illustrate we can begin this tuning process by running the above analysis using a different dimension reduction technique.

```{r}
# Perform Slingshot analysis using TSNE
slingshot_tsne <- slingshot(sce, 
                            clusterLabels = sce$ClusterName,
                            reducedDim = "TSNE",
                            start.clus = "Nbl1")
```

As before, we visualise the results of slingshot, this time using TSNE as the reduced dimensions. We can see that like before we are able to identify three distinct lineages. 
```{r}
rd_tsne <- reducedDim(slingshot_tsne, "TSNE")
df_toPlot$TSNE1 <- rd_tsne[, 1]
df_toPlot$TSNE2 <- rd_tsne[, 2]
curves_tsne <- slingCurves(slingshot_tsne, as.df = TRUE)
pseudotime_tsne <- slingshot::slingPseudotime(slingshot_tsne)

ggplot() +
  geom_point(data = df_toPlot, aes(x = TSNE1, y = TSNE2, color = ClusterName)) +
  geom_path(data = curves_tsne,
            aes(x = Dim.1, y = Dim.2, group = Lineage)) +
  scale_color_tableau(palette = "Classic 10") +
  theme(aspect.ratio = 1)
```

By plotting the correlation between the inferred pseudotime values, we can see that the trajectories the built based on UMAP and tSNE reduced dimension space are highly correlated with each other (cor > 0.99). We illustrate the results for `Lineage 1`.
```{r}
par(pty = "s")
plot(pseudotime_tsne[, 1], pseudotime_umap[, 1], ylab = "Pseudotime from UMAP", xlab = "Pseudotime from TSNE")
cor(pseudotime_tsne[, 1], pseudotime_umap[, 1], use = "complete.obs")
```

**Discussion:** 

+ Would performing dimensionality reduction with a different set/number of selected features impact the trajectory results?

### 3.4 How well do the pseudotime orderings correlate from different trajectory methods?

As an example to illustrate the concordance between the results from running two different trajectory inference methods, here we will use `monocle3` to construct the trajectory on the same UMAP space and compare it against the results from `slingshot`. 

```{r}
library(monocle3)
# Construt cell data set object for monocle3
rowData(sce) <- DataFrame(rowData(sce), gene_short_name = rownames(sce))
cds <- as(sce, "cell_data_set")
cds <- cluster_cells(cds, reduction_method = "UMAP")
cds <- learn_graph(cds, use_partition = FALSE) # set use_partition to FALSE so only a single graph is learnt
```

Similar to the approach using `slingshot`, visualisation of the `monocle3` approach shows three distinct lineages, replicating two bifurcation points at `Nbl2` and `CA`.
```{r}
plot_cells(cds,
           color_cells_by = "ClusterName",
           label_groups_by_cluster = FALSE,
           label_leaves = FALSE,
           label_branch_points = FALSE) +
  scale_color_tableau(palette = "Classic 10") +
  theme(aspect.ratio = 1)
```

We can now calculate the pseudotimes. Note that it is important to set the cell type of origin (i.e., the cell type denoting the earliest temporal point of the differentiation when calculating pseudotimes. For `monocle3`, we will need to provide the `root_cells`, which requires us to specify a set of cells from the root cell type. By creating a customised function `get_earliest_principal_node` to do this, we can arbitrarily assign a set of cell from the cell type of origin as our `root_cells`. 
```{r}
get_earliest_principal_node <- function(cds, coldata_name, start.clust){
  cell_ids <- which(colData(cds)[, coldata_name] == start.clust)
  closest_vertex <- cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <- igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names(which.max(table(closest_vertex[cell_ids,]))))]
  root_pr_nodes
}

# Set the root cells
root_cells <- get_earliest_principal_node(cds, coldata_name = "ClusterName",
                                          start.clust = "Nbl1")
# Order the cells to calculate pseudotime
cds <- order_cells(cds, 
                   root_pr_nodes = root_cells)

plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups = FALSE,
           label_leaves = FALSE,
           label_branch_points = FALSE,
           graph_label_size = 1.5) +
  theme(aspect.ratio = 1)

monocle3_pseudotime <- cds@principal_graph_aux[["UMAP"]]$pseudotime
```

Again, we can evaluate the concordance in pseudotimes inferred across the two trajectory inference methods, `slingshot` and `monocle3`. Are you satisfied with the agreement? 
```{r}
par(pty = "s")
plot(monocle3_pseudotime, pseudotime_umap[, 1], xlab = "Monocle 3", ylab = "Slingshot (Lineage 1)")
cor(monocle3_pseudotime, pseudotime_umap[, 1], use = "complete.obs")
```

**Discussion:** 

+ Can we use `order_cells` in `monocle3` if we do not know what the `root` cell type is?

### 3.5 Extension: RNA velocity vs trajectory pseudotime inference [OPTIONAL]

```{r cache=TRUE}
library(velocyto.R)
emat <- assay(sce, "spliced")
nmat <- assay(sce, "unspliced")
cluster.label <- sce$ClusterName
names(cluster.label) <- colnames(sce)
# Use UMAP embeddings
emb <- reducedDim(sce, "UMAP")
pca <- reducedDim(sce, "PCA")
# Calculate distance
cell.dist <- as.dist(1 - armaCor(t(pca)))

# Filtering the genes
emat <- filter.genes.by.cluster.expression(emat, cluster.label, min.max.cluster.average = 0.5)
nmat <- filter.genes.by.cluster.expression(nmat, cluster.label, min.max.cluster.average = 0.05)

# Using 3838 genes for velocity estimation
length(intersect(rownames(emat), rownames(emat)))

rvel.cd <- gene.relative.velocity.estimates(emat, nmat, deltaT = 1,
                                            kCells = 20, cell.dist = cell.dist,
                                            fit.quantile = 0.02, n.cores = 1)
plotcol <- tableau_color_pal("Classic 10")(10)[as.factor(cluster.label)]
names(plotcol) <- names(cluster.label)
par(pty = "s")
show.velocity.on.embedding.cor(emb, rvel.cd, n = 300, scale = 'sqrt',
                               cell.colors = ac(plotcol, alpha=0.5), 
                               cex = 0.8, arrow.scale = 5, show.grid.flow = TRUE,
                               min.grid.cell.mass = 0.5, grid.n = 40,
                               arrow.lwd = 1, do.par = F, cell.border.alpha = 0.1,
                               n.cores = 1)
```

## 4. How can I characterise the trajectory of the data?

So far, we have built a trajectory from our mouse hippocampus data using the transcriptomes of single cells. During this process, we determined the presence of three distinct lineages in the trajectory, observed two bifurcation events (or branching) in the data that was in line with the underlying biological system, and investigated the impact of using different dimensionality reduction techniques and different methods of trajectory inference. 

We can now being to further phenotype the trajectories by investigating the changes in the specific gene expressions programs across and between lineages. We will ask the following questions: 
  - Within a lineage, which genes are differentially expressed across a pseudotime?
  - Which genes exhibit different patterns of gene expression across the pseudotime between lineages?
  - Can we group the genes in terms of their gene expression patterns across the pseudotime?
  - Are specific pathways or gene sets enriched in these gene groups?
  - Which gene-pair correlations change across lineages? 
  
### 4.1 Within a lineage, which genes are differentially expressed across a pseudotime?

Using `tradeSeq` [Berge et al., 2020](https://www.nature.com/articles/s41467-020-14766-3) and our output of `slingshot`, we can find genes that are differentially expressed along one or multiple lineages in a trajectory. To reduce time, we perform the analysis using the set of differentially stable genes (643 genes) derived earlier. 

The first step of the `tradeSeq` framework is to fit the NB-GAMs. One of the important parameters in fitting this model is the choice of knot number. This parameter indicates how complex the expression patterns are in the data, where a higher number of knots allows for more complex expression patterns. The most optimal choice of knots can be derived from using the `evaluteK` function. We have performed this for you and set `knots = 6` when fitting the NB-GAM. Note that if your data contains multiple conditions, you should fit individual smoothers for each condition using the argument `conditions`. 
```{r}
library(tradeSeq)
slingshot_umap <- slingshot_umap[!duplicated(rownames(slingshot_umap)),]
slingshot_umap <- fitGAM(slingshot_umap,
                         genes = cepoGenes,
                         nknots = 6,
                         verbose = TRUE,
                         parallel = FALSE,
                         sce = TRUE,
                         family = "nb",
                         gcv = FALSE)
table(rowData(slingshot_umap)$tradeSeq$converged)
```

Next, using the fitted gene expressions, we can assess for significant changes in gene expression (i.e., differential expression) as a function of pseudotime within each lineage using the `associationTest` function. Importantly, setting `lienages = TRUE` will specify that the differential expression analysis should be performed for each lineage separately, as well as performing the test across all lineages simultaneously. 

```{r eval = TRUE}
assoRes <- associationTest(slingshot_umap, global = TRUE, lineages = TRUE)
assoRes <- assoRes[cepoGenes,]
assoRes <- assoRes[order(assoRes$waldStat, decreasing = TRUE),]
datatable(assoRes) %>%
  formatSignif(which(sapply(assoRes, is, 'numeric')), digits = 3)
```
We see there is a large overlap in DE genes between the three lineages (around 97%).

```{r}
lineage1Genes <-  rownames(assoRes)[
  which(p.adjust(assoRes$pvalue_1, "fdr") <= 0.05)
]
lineage2Genes <-  rownames(assoRes)[
  which(p.adjust(assoRes$pvalue_2, "fdr") <= 0.05)
]
lineage3Genes <-  rownames(assoRes)[
  which(p.adjust(assoRes$pvalue_3, "fdr") <= 0.05)
]
allGenes <-  rownames(assoRes)[
  which(p.adjust(assoRes$pvalue, "fdr") <= 0.05)
]

DEgenes = list(
  lineage1 = lineage1Genes,
  lineage2 = lineage3Genes,
  lineage3 = lineage3Genes
)
sapply(DEgenes, length)
UpSetR::upset(UpSetR::fromList(DEgenes))
```

We can visualise the gene expression of a DE gene to check that its expression indeed change over pseudotime within each lineage. As an example, we select `Lingo2`, a gene that has been found to be differentially expressed for all three lineages. 

```{r eval = TRUE}
plotSmoothers(slingshot_umap, counts(slingshot_umap), gene = c("Lingo2"))
```

### 4.2 Which genes exhibit different patterns of gene expression across the pseudotime between lineages?

Whilst the `associationTest` looks for genes that show differential expression across a pseudotime within a lineage, we can also look for genes that demonstrate different differential expression patterns across lineages through the `patternTest` function. For each gene, we can test whether its expression pattern differs between lineages.
```{r eval = TRUE}
patternRes <- patternTest(slingshot_umap)
patternRes <- patternRes[cepoGenes,]
patternRes <- patternRes[order(patternRes$waldStat, decreasing = TRUE),]
datatable(patternRes) %>%
  formatSignif(which(sapply(patternRes, is, 'numeric')), digits = 3)
```

Note 592 of 643 genes demonstrate differential gene expression patterns between lineages.
```{r}
patternGenes <-  rownames(patternRes)[
  which(p.adjust(patternRes$pvalue, "fdr") <= 0.05)
]
length(patternGenes)
```

We can confirm this is the case by visualising the change in the expression of the most significant gene, `Cntnap5a`. 
```{r eval = TRUE}
plotSmoothers(slingshot_umap, counts(slingshot_umap), gene = c("Cntnap5a"))
```

### 4.3 Can we group the genes in terms of their gene expression patterns across the pseudotime?

Using the `patternTest`, we have obtained a statistical significance for each gene, a value that reflects how significantly a gene's expression as a function of pseudotime is distinct between lineages. We can further cluster genes according to their expression pattern along the pseudotime for each lineage using the `clusterExpressionPattern` function from `tradeSeq`. The resulting output is a clustering label that denotes gene groups based on like gene expression profiles. The main arguments of the function are 1) the slingshot output, 2) `nPoints` which denotes the number of points along each lineage to cluster the genes, and 3) the `genes` to use in the clustering. More details of the implementation can be found in [this vignette](https://statomics.github.io/tradeSeq/articles/tradeSeq.html).

Note that the clustering uses the clusterExperiment package (Risso et al. 2018), hence the user may select any clustering algorithm thatâ€™s built into that package (check the output of `clusterExperiment::listBuiltInFunctions()` on the command line to see available methods).

```{r}
library(clusterExperiment)
nPointsClus <- 20
clusPat <- clusterExpressionPatterns(slingshot_umap, nPoints = nPointsClus,
                                     genes = rownames(patternRes))
clusterLabels <- primaryCluster(clusPat$rsec)

cUniq <- unique(clusterLabels)
cUniq <- cUniq[!cUniq == -1] # remove unclustered genes
```

After running the `clusterExpressionPatterns` function we can see that there are in total 52 clustering groups. Note that there are also 98 genes that have not been assigned to a cluster and may demonstrate unique gene expression patterns.
```{r}
table(clusterLabels)
```

As an example, we will visualise the normalised expression patterns of genes from three clusters. Can you describe the various expression patterns? Note that there are two layers of differences: genes show (1) differential expression across a pseudotime within a lineage **and** (2) these differential expression patterns are significantly different between lineages. 
```{r}
ggCluster <- list()
for (xx in 1:4) {
  cId <- which(clusterLabels == c(2,3,6,7)[[xx]])
  p <- ggplot(data = data.frame(x = 1:nPointsClus,
                                y = rep(range(clusPat$yhatScaled[cId, ]),
                                        nPointsClus / 2)),
              aes(x = x, y = y)) +
    geom_point(alpha = 0) +
    labs(title = paste0("Cluster ", c(2,3,6,7)[[xx]]),  x = "Pseudotime", y = "Normalized expression") +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5))
  for (ii in 1:length(cId)) {
    geneId <- rownames(clusPat$yhatScaled)[cId[ii]]
    p <- p +
      geom_line(data = data.frame(x = rep(1:nPointsClus, 3),
                                  y = clusPat$yhatScaled[geneId, ],
                                  lineage = rep(1:3, each = nPointsClus)),
                aes(col = as.character(lineage), group = lineage), lwd = 1.5)
  }
  ggCluster[[xx]] <- p + guides(color = FALSE) +
    scale_color_manual(values = c("orange", "darkseagreen3", "darkblue"),
                       breaks = c("1", "2", "3"))  
}

patchwork::wrap_plots(ggCluster, ncol = 4, nrow = 1)
```

**Discussion:** 

+ Would setting a greater number of `nPoints` (e.g., 40, 60, 80) change the clustering results? 

### 4.4 Are specific pathways or gene sets enriched in these gene groups?

The output of the `clusterExpressionPatterns` function is clusters of genes. We can next investigate whether a specific set of genes are enriched in these gene groups that demonstrate a similar pattern of gene expression across a lineage using gene set over-representation (GO) analysis. As an example, we will investigate which gene sets are over-represented in cluster 2 (38 genes).
```{r}
names(clusterLabels) <- rownames(clusPat$yhatScaled)

library(clusterProfiler)
library(org.Mm.eg.db)
eg <- bitr(names(clusterLabels)[clusterLabels == 2],
           fromType = "SYMBOL",
           toType = "ENTREZID",
           OrgDb = "org.Mm.eg.db")

geneList <- bitr(rownames(slingshot_umap),
                 fromType = "SYMBOL", 
                 toType = "ENTREZID", 
                 OrgDb = "org.Mm.eg.db")

ego_res <- enrichGO(gene = eg$ENTREZID,
                    universe = geneList$ENTREZID,
                    OrgDb = org.Mm.eg.db,
                    ont = "BP",
                    pAdjustMethod = "BH",
                    minGSSize = 20,
                    maxGSSize = 200,
                    pvalueCutoff = 1,
                    qvalueCutoff = 1,
                    readable = TRUE)
```

We can visualise the results as a table.
```{r}
head(summary(ego_res))
```

The `clusterProfiler::dotplot` function can be used to visualise the results for the top significant pathways as a dot plot where the size of the circle represents the number of genes identified for the pathway of interest and the color of the function denotes the level of significance. 
```{r}
dotplot(ego_res)
```

**Discussion:** 

+ What are the top enriched pathways from the gene set over-representation analysis? Are the results in line with what you expect?

### 4.5 Which gene-pair correlations change across lineages? 

Lastly, using an algorithm called `scHOT` [Ghzanfar et al., 2020](https://www.nature.com/articles/s41592-020-0885-x), we can further test the change in gene expression of **a pair of genes** across a pseudotime. 

To reduce computation time, we will select the top 10 genes identified from `associationTest` in 4.1. Using the top 10 genes, we generate a total of 45 gene pairs to test.
```{r}
library(scHOT)

first_branch_cells <- !is.na(slingshot_umap$slingPseudotime_1)
assoRes_lingeag1_top10 <- rownames(assoRes[order(assoRes$waldStat_1, decreasing = TRUE),])[1:10]
gene_to_test <- t(combn(assoRes_lingeag1_top10, 2))
```

There are two statistical higher order testing we can perform, controlled by the `higherOrderFunction` argument in `scHOT`. We can test for **differential variability** or **differential correlation** between pairs of genes across the pseudotime.
   1) variability: `higherOrderFunction = matrixStats::weightedVar`
   2) correlation: `higherOrderFunction = matrixStats::weightedSpearman` 

As an illustration, we will investigate whether there are gene pairs that demonstrate differential correlation across the pseudotime for each lineage. 
```{r}
scHOT_obj <- scHOT_buildFromMatrix(
  mat = logcounts(slingshot_umap)[,first_branch_cells],
  cellData = list(pseudotime = slingshot_umap$slingPseudotime_1[first_branch_cells]),
  positionType = "trajectory",
  positionColData = "pseudotime")
scHOT_obj

scHOT_obj <- scHOT(scHOT_obj,
                   testingScaffold = gene_to_test,
                   nrow.out = 100, # The number of weightings to include for testing, a smaller value is faster for computation
                   higherOrderFunction = weightedSpearman,
                   higherOrderFunctionType = "weighted",
                   numberPermutations = 50)

scHOT_obj@scHOT_output <- scHOT_obj@scHOT_output[order(scHOT_obj@scHOT_output$FDREstimated),]
```

Finally, we can visualise the results of the top 5 significant genes that demonstrate differential correlation across our pseudotime. 

```{r}
plotHigherOrderSequence(scHOT_obj, rownames(scHOT_obj@scHOT_output)[1:5])
```

## 5. Cell-cell communication

```{r}
library(CellChat)
cellchat <- createCellChat(object = logcounts(sce), 
                           meta = data.frame(colData(sce)), 
                           group.by = "ClusterName")

cellchat <- setIdent(cellchat, ident.use = "ClusterName") # set "labels" as default cell identity
levels(cellchat@idents) # show factor levels of the cell labels
```



```{r}
cellchat@DB <- CellChatDB.mouse # Set CellChat Database
cellchat <- subsetData(cellchat)

cellchat <- identifyOverExpressedGenes(cellchat)
cellchat <- identifyOverExpressedInteractions(cellchat)


```





```{r}
#Compute the communication probability and infer cellular communication network
cellchat <- computeCommunProb(cellchat)
# Filter out the cell-cell communication if there are only few number of cells in certain cell groups
cellchat <- filterCommunication(cellchat, min.cells = 10)
#Infer the cell-cell communication at a signaling pathway level
cellchat <- computeCommunProbPathway(cellchat)
```

```{r}
cellchat <- aggregateNet(cellchat)
```

```{r}
groupSize <- as.numeric(table(cellchat@idents))
par(mfrow = c(1,2), xpd=TRUE)
netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")
netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")
```


```{r}
pathways.show <- c("NCAM") 
# Hierarchy plot
# Here we define `vertex.receive` so that the left portion of the hierarchy plot shows signaling to fibroblast and the right portion shows signaling to immune cells 
vertex.receiver = seq(1,4) # a numeric vector. 
netVisual_aggregate(cellchat, signaling = pathways.show,  vertex.receiver = vertex.receiver)
netVisual_heatmap(cellchat, signaling = pathways.show, color.heatmap = "Reds")
```

```{r}
netVisual_bubble(cellchat, sources.use = 1, targets.use = 2:7, remove.isolate = FALSE)
```


## Reference and other useful resources:

+ dynverse, a collection of R packages aimed at supporting the trajectory inference: https://dynverse.org
+ RNA velocity: http://velocyto.org


